package store

import (
	"container/list"
	"fmt"
	"sync"
)

var StreamManager = newStreamsManager()

type StreamsStore interface {
	XAdd(stream, id string, data map[string]string) (streamRecord, error)
	XRange(stream, startId, endId string) ([]streamRecord, error)
	XGetStream(stream string) (*stream, bool)
	XRead(stream, id string) (streamRecord, bool)
}

type streamRecord struct {
	Id               string // store ID (Milliseconds-SequenceNumber), this is most probably done to make it monotonically increasing, not completely dependent on the time(due to time-of-the-day clock skew), not sure though
	MillisecondsTime int64
	SequenceNumber   int
	Data             map[string][]byte // Key-value data for the record
}

type stream struct {
	mu sync.RWMutex
	// Maps record ID to its corresponding list element for O(1) lookups
	recordMap  map[string]*list.Element // Fast lookup of records by ID
	recordList *list.List               // Doubly linked list for ordered storage
}

// Maps stream names to corresponding stream object
type StreamsManager struct {
	Streams map[string]*stream // Map of stream names to Stream objects, for faster lookups
}

func newStream() *stream {
	return &stream{
		recordMap:  make(map[string]*list.Element),
		recordList: list.New(),
	}
}

func newStreamsManager() *StreamsManager {
	return &StreamsManager{
		Streams: make(map[string]*stream),
	}
}

/*
 	* xAdd adds a new entry to a stream
	* @param streamName string - the name of the stream
	* @param id string - the ID of the new entry
	* @param data map[string][]byte - the data for the new entry
	* @return streamRecord - the new entry
	* @return bool - true if the entry was added successfully, false otherwise
	* @return error - the error if there is one
*/
func (sm *StreamsManager) XAdd(streamName, id string, data map[string][]byte) (streamRecord, bool, error) {

	if !sm.IsStreamKey(streamName) {
		sm.Streams[streamName] = newStream()
	}
	valid, err := sm.verifyStreamId(streamName, id)
	if !valid {
		return streamRecord{}, false, err
	}

	isFullAutoGenerated, millisecondsTime, sequenceNumber, err := sm.parseStreamId(id)
	if err != nil {
		return streamRecord{}, false, err
	}

	var newId string = id
	var newMillisecondsTime int64 = millisecondsTime
	var newSequenceNumber int = sequenceNumber

	if isFullAutoGenerated {
		newId, newMillisecondsTime, newSequenceNumber, err = sm.generateStreamId(streamName, id, false)
		if err != nil {
			return streamRecord{}, false, err
		}
	}

	if sequenceNumber == -1 {
		newId, newMillisecondsTime, newSequenceNumber, err = sm.generateStreamId(streamName, id, true)
		if err != nil {
			return streamRecord{}, false, err
		}
	}

	stream := sm.Streams[streamName]
	stream.mu.Lock()
	defer stream.mu.Unlock()

	streamRecord := streamRecord{
		Id:               newId,
		MillisecondsTime: newMillisecondsTime,
		SequenceNumber:   newSequenceNumber,
		Data:             data,
	}
	element := stream.recordList.PushBack(&streamRecord)
	stream.recordMap[newId] = element

	return streamRecord, true, nil
}

/*
 	* XRange gets a range of entries from a stream
	* @param streamName string - the name of the stream
	* @param startId string - the ID of the start of the range
	* @param endId string - the ID of the end of the range
	* @return []streamRecord - the range of entries, inclusive of the start and end IDs
	* @return error - the error if there is one
*/
func (sm *StreamsManager) XRange(streamName, startId, endId string) ([]streamRecord, error) {
	if !sm.IsStreamKey(streamName) {
		return nil, fmt.Errorf("ERR The stream specified does not exist")
	}

	exists, err := sm.IsValidStreamRecordIdExists(streamName, startId, "range")
	if !exists {
		return nil, err
	}

	exists, err = sm.IsValidStreamRecordIdExists(streamName, endId, "range")
	if !exists {
		return nil, err
	}

	stream := sm.Streams[streamName]

	stream.mu.RLock()
	defer stream.mu.RUnlock()

	var startElem *list.Element
	var endElem *list.Element

	if startId == "+" || endId == "-" {
		return nil, fmt.Errorf("ERR The start or end ID is invalid")
	}

	if startId == "-" {
		startElem = stream.recordList.Front()
	} else {
		startElem = stream.recordMap[startId]
	}

	if endId == "+" {
		endElem = stream.recordList.Back()
	} else {
		endElem = stream.recordMap[endId]
	}

	var result []streamRecord
	current := startElem

	for current != nil {
		record := current.Value.(*streamRecord)
		result = append(result, *record)

		if current == endElem {
			break
		}
		current = current.Next()
	}

	return result, nil
}

/*
 	* XRead gets a range of entries from a stream, exclusive of the start ID
	* @param streamName string - the name of the stream
	* @param startId string - the ID of the start of the range
	* @return []streamRecord - the range of entries, exclusive of the start ID
	* @return error - the error if there is one
*/
func (sm *StreamsManager) XRead(streamName, startId string) ([]streamRecord, error) {
	if !sm.IsStreamKey(streamName) {
		return nil, fmt.Errorf("ERR The stream specified does not exist")
	}

	exists, err := sm.IsValidStreamRecordIdExists(streamName, startId, "read")

	if !exists && startId != "0-0" {
		return nil, err
	}

	stream := sm.Streams[streamName]

	stream.mu.RLock()
	defer stream.mu.RUnlock()

	var result []streamRecord

	var startElem *list.Element
	var current *list.Element

	if startId == "0-0" {
		startElem = stream.recordList.Front()
		current = startElem
	} else {
		startElem = stream.recordMap[startId]
		current = startElem.Next()
	}

	for current != nil {
		record := current.Value.(*streamRecord)
		result = append(result, *record)

		current = current.Next()
	}

	return result, nil

}
