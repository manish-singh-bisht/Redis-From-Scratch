package store

import (
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	RESP "github.com/manish-singh-bisht/Redis-From-Scratch/db/resp"
)

type operationType string

var ErrInvalidStream = errors.New("ERR The stream specified does not exist")
var ErrInvalidStreamId = errors.New("ERR Invalid stream ID format")
var ErrInvalidStreamIdXAdd = errors.New("ERR The ID specified in XADD is equal or smaller than the target stream top item")
var ErrInvalidMsTime = errors.New("ERR The millisecondsTime part of the ID specified is invalid")
var ErrInvalidSeqNum = errors.New("ERR The sequenceNumber part of the ID specified is invalid")
var ErrUnexpectedTypeInListElement = errors.New("ERR Unexpected type in list element")
var ErrInvalidStreamIdXAddMustBeGreaterThanMin = errors.New("ERR The ID specified in XADD must be greater than 0-0")

func unknownOperationType(op operationType) error {
	return fmt.Errorf("ERR Unknown operation type for id validator: %v", op)
}

const (
	operationTypeRange operationType = "range"
	operationTypeRead  operationType = "read"
)

const (
	streamIDMin      = "0-0"
	streamIDWildcard = "*"
	rangeQueryStart  = "-"
	rangeQueryEnd    = "+"
	streamIDLast     = "$"
)

const (
	autoGeneratedSeq        = -1
	autoGeneratedTimeAndSeq = -2
)

type iDValidator func(string) bool

var operationValidators = map[operationType]iDValidator{
	operationTypeRange: isRangeQueryMarker,
	operationTypeRead:  func(id string) bool { return false }, // for no specific checks always return false for now
}

/**
 * isRangeQueryMarker checks if the id is a range query marker like "-" or "+"
 * @param id string - the ID to check
 * @return bool - true if the ID is a range query marker, false otherwise
 */
func isRangeQueryMarker(id string) bool {
	return id == rangeQueryStart || id == rangeQueryEnd
}

/**
 * isWildcard checks if the id is a wildcard i.e. "*"
 * @param id string - the ID to check
 * @return bool - true if the ID is a wildcard, false otherwise
 */
func isWildcard(id string) bool {
	return id == streamIDWildcard
}

/**
 * isMinStreamID checks if the id is the minimum stream ID i.e. 0-0
 * @param id string - the ID to check
 * @return bool - true if the ID is the minimum stream ID, false otherwise
 */
func isMinStreamID(id string) bool {
	return id == streamIDMin
}

/**
 * getCurrentMillisTime returns the current milliseconds time
 * @return int64 - the current milliseconds time
 */
func getCurrentMillisTime() int64 {
	return time.Now().UnixNano() / int64(time.Millisecond)
}

/**
 * isStreamKey checks if a stream key exists
 * @param key string - the key to check
 * @return bool - true if the key exists, false otherwise
 */
func (sm *streamManager) isStreamKey(key string) bool {
	_, exists := sm.streams[key]
	return exists
}

/**
 * isValidStreamRecordIdExists checks if a stream record ID exists
 * @param streamName string - the name of the stream
 * @param id string - the ID to check
 * @param typeOfOperation string - the type of operation, "range" or "read" etc
 * @return bool - true if the ID exists, false otherwise
 */
func (sm *streamManager) isValidStreamRecordIdExists(streamName string, id string, op operationType) (bool, error) {
	if !sm.isStreamKey(streamName) {
		return false, ErrInvalidStream
	}

	// some checks for specific operations like range where we need to check the id is a range query marker like "-" or "+"
	validator, exists := operationValidators[op]
	if !exists {
		return false, unknownOperationType(op)
	}

	if validator(id) {
		return true, nil
	}

	stream := sm.streams[streamName]
	stream.mu.RLock()
	defer stream.mu.RUnlock()

	_, exists = stream.recordMap[id]
	return exists, nil
}

/**
 * The ID should be greater than the ID of the last entry in the stream.
 * The millisecondsTime part of the ID should be greater than or equal to the millisecondsTime of the last entry.
 * If the millisecondsTime part of the ID is equal to the millisecondsTime of the last entry, the sequenceNumber part of the ID should be greater than the sequenceNumber of the last entry.
 * If the stream is empty, the ID should be greater than 0-0
 */
func (sm *streamManager) verifyStreamId(streamName, id string) (bool, error) {
	if !sm.isStreamKey(streamName) {
		return false, ErrInvalidStream
	}

	stream := sm.streams[streamName]

	// check for "0-0"
	if isMinStreamID(id) {
		return false, ErrInvalidStreamIdXAddMustBeGreaterThanMin
	}

	wildcardNum, msTime, seqNum, err := sm.parseStreamId(id)
	if err != nil {
		return false, err
	}

	// if the id is a wildcard or auto sequence, then it is valid
	if wildcardNum == autoGeneratedTimeAndSeq || wildcardNum == autoGeneratedSeq {
		return true, nil
	}

	lastEntry := stream.recordList.Back()

	if lastEntry == nil {

		// if id is greater than 0-0
		if msTime > 0 || (msTime == 0 && seqNum > 0) {
			return true, nil
		}

		return false, ErrInvalidStreamIdXAddMustBeGreaterThanMin
	}

	lastEntryRecord, ok := lastEntry.Value.(*StreamRecord)
	if !ok {
		return false, ErrUnexpectedTypeInListElement
	}

	if lastEntryRecord.millisecondsTime > msTime {
		return false, ErrInvalidStreamIdXAdd
	}

	if lastEntryRecord.millisecondsTime == msTime && lastEntryRecord.sequenceNumber >= seqNum {
		return false, ErrInvalidStreamIdXAdd
	}

	return true, nil
}

/**
 * parseStreamId parses a stream ID into millisecondsTime and sequenceNumber
 * -1 means that the sequenceNumber is auto generated
 * -2 means that the millisecondsTime and sequenceNumber are auto generated
 * @param id string - the ID to parse
 * @return int - the type of the ID, 0 means that the ID is not auto generated, -1 means that the sequence is auto generated, -2 means that the millisecondsTime and sequenceNumber are auto generated
 * @return int64 - the millisecondsTime part of the ID
 * @return int - the sequenceNumber part of the ID
 * @return error - the error if there is one
 */
func (sm *streamManager) parseStreamId(id string) (int, int64, int, error) {

	// check if the id is a wildcard, i.e. id="*"
	if isWildcard(id) {
		return autoGeneratedTimeAndSeq, 0, 0, nil
	}

	idParts := strings.Split(id, "-")
	if len(idParts) != 2 {
		return 0, 0, 0, ErrInvalidStreamId
	}
	// not checking for seqNum wildcard first and parsing the correctness of msTime because we still send the msTime incase of wildcard seqNum
	msTime, err := strconv.ParseInt(idParts[0], 10, 64)
	if err != nil {
		return 0, 0, 0, ErrInvalidMsTime
	}

	//  check if the sequenceNumber is a wildcard, i.e. idParts[1]="*", eg: 123-*,
	if isWildcard(idParts[1]) {
		return autoGeneratedSeq, msTime, 0, nil
	}

	seqNum, err := strconv.Atoi(idParts[1])
	if err != nil {
		return 0, 0, 0, ErrInvalidSeqNum
	}

	return 0, msTime, seqNum, nil
}

/**
 * generateStreamId generates a new stream ID
 * @param streamName string - the name of the stream
 * @param id string - the ID of the new entry
 * @return string - the new stream ID
 * @return int64 - the millisecondsTime part of the new stream ID
 * @return int - the sequenceNumber part of the new stream ID
 * @return error - the error if there is one
 */
func (sm *streamManager) generateStreamId(streamName string, id string) (string, int64, int, error) {

	if !sm.isStreamKey(streamName) {
		return "", 0, 0, ErrInvalidStream
	}

	stream := sm.streams[streamName]
	wildcardNum, msTime, _, err := sm.parseStreamId(id)
	if err != nil {
		return "", 0, 0, err
	}

	lastEntry := stream.recordList.Back()
	if lastEntry == nil {
		return sm.generateFirstId(msTime, wildcardNum)
	}

	lastRecord, ok := lastEntry.Value.(*StreamRecord)
	if !ok {
		return "", 0, 0, ErrUnexpectedTypeInListElement
	}

	return sm.generateNextId(lastRecord, msTime, wildcardNum)
}

/**
 * generateFirstId generates the stream ID for the first entry in the stream
 * @param msTime int64 - the millisecondsTime part of the new stream ID
 * @param wildcardNum int - the type of the ID, 0 means that the ID is not auto generated, -1 means that the sequence is auto generated, -2 means that the millisecondsTime and sequenceNumber are auto generated
 * @return string - the new stream ID
 * @return int64 - the millisecondsTime part of the new stream ID
 * @return int - the sequenceNumber part of the new stream ID
 * @return error - the error if there is one
 */
func (sm *streamManager) generateFirstId(msTime int64, wildcardNum int) (string, int64, int, error) {
	if wildcardNum == autoGeneratedSeq && msTime > 0 {
		// If the seqNum is auto-generated and msTIme is provided,
		// generate an ID with seqNum 0.
		return fmt.Sprintf("%d-0", msTime), msTime, 0, nil
	} else if msTime == 0 && wildcardNum == autoGeneratedSeq {
		// If both msTIme is 0,
		// default to 0 msTIme and seqNum 1.
		return fmt.Sprintf("%d-1", msTime), msTime, 1, nil
	} else if wildcardNum == autoGeneratedTimeAndSeq {
		// If wildcardNum indicates automatic time and seqNum generation,
		// use the current system time and start with seqNum 0.
		currentTime := getCurrentMillisTime()
		return fmt.Sprintf("%d-0", currentTime), currentTime, 0, nil
	}

	return "", 0, 0, ErrInvalidStreamId
}

/**
 * generateNextId generates the stream ID for the next entry in the stream
 * @param lastRecord *StreamRecord - the last entry in the stream
 * @param msTime int64 - the millisecondsTime part of the new stream ID
 * @param wildcardNum int - the type of the ID, 0 means that the ID is not auto generated, -1 means that the sequence is auto generated, -2 means that the millisecondsTime and sequenceNumber are auto generated
 * @return string - the new stream ID
 * @return int64 - the millisecondsTime part of the new stream ID
 * @return int - the sequenceNumber part of the new stream ID
 * @return error - the error if there is one
 */
func (sm *streamManager) generateNextId(lastRecord *StreamRecord, msTime int64, wildcardNum int) (string, int64, int, error) {
	var newSeqNum int
	var newMsTime int64

	if wildcardNum == autoGeneratedSeq {

		if msTime == lastRecord.millisecondsTime {
			newSeqNum = lastRecord.sequenceNumber + 1
		} else {
			newSeqNum = 0
		}
		newMsTime = msTime
	} else {

		if msTime == lastRecord.millisecondsTime {
			newSeqNum = lastRecord.sequenceNumber + 1
		} else {
			newSeqNum = 0
		}
		newMsTime = time.Now().UnixNano() / int64(time.Millisecond)
	}

	return fmt.Sprintf("%d-%d", newMsTime, newSeqNum), newMsTime, newSeqNum, nil
}

/*
 	* createStreamMessages converts stream records to RESP messages
	* @param records []store.StreamRecord - the stream records to convert
	* @return []RESP.RESPMessage - the RESP messages
*/
func (sm *streamManager) createStreamMessages(records []StreamRecord) []RESP.RESPMessage {
	entries := make([]RESP.RESPMessage, len(records))
	for i, record := range records {
		// Create key-value pairs array, thus record.Data*2
		kvPairs := make([]RESP.RESPMessage, 0, len(record.Data)*2)
		for key, value := range record.Data {
			kvPairs = append(kvPairs,
				RESP.RESPMessage{
					RESPType:  RESP.BulkString,
					RESPLen:   len(key),
					RESPValue: []byte(key),
				},
				RESP.RESPMessage{
					RESPType:  RESP.BulkString,
					RESPLen:   len(value),
					RESPValue: value,
				},
			)
		}

		entries[i] = RESP.RESPMessage{
			RESPType: RESP.Array,
			RESPLen:  2,
			RESPArrayElem: []RESP.RESPMessage{
				{
					RESPType:  RESP.BulkString,
					RESPLen:   len(record.Id),
					RESPValue: []byte(record.Id),
				},
				{
					RESPType:      RESP.Array,
					RESPLen:       len(kvPairs),
					RESPArrayElem: kvPairs,
				},
			},
		}
	}
	return entries
}

/*
 	* subscribe subscribes a subscriber to the stream, adds a channel to the map and returns the channel
	* @return chan struct{} - the channel to subscribe to
*/
func (s *stream) subscribe() chan struct{} {
	// s.mu.Lock()
	// defer s.mu.Unlock()
	// keeping no locks here because we use it in the parent function, but what if we want to use it in other functions and that has no locks?not sure if this statement itself is right.
	ch := make(chan struct{}, 1)
	s.subscribers[ch] = struct{}{}
	return ch
}

/*
 	* unsubscribe unsubscribes a subscriber from the stream, deletes the channel from the map and closes the channel
	* @param ch chan struct{} - the channel to unsubscribe
*/
func (s *stream) unsubscribe(ch chan struct{}) {
	// s.mu.Lock()
	// defer s.mu.Unlock()
	// keeping no locks here because we use it in the parent function, but what if we want to use it in other functions and that has no locks?not sure if this statement itself is right.

	delete(s.subscribers, ch)
	close(ch)
}

/*
 	* notifySubscribers notifies all subscribers of a new record
	* @param s *Stream - the stream to notify subscribers of
*/
func (s *stream) notifySubscribers() {
	// s.mu.Lock()
	// defer s.mu.Unlock()
	// keeping no locks here because we use it in the parent function, but what if we want to use it in other functions and that has no locks?not sure if this statement itself is right.

	for ch := range s.subscribers {

		select {
		case ch <- struct{}{}:
		default: // missing a notification is okay because the subscriber will check for new records anyway
		}
	}
}
